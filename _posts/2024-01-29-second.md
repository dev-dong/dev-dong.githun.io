---
layout: single
title: "Git Flow란, Git 브랜치 전략"
categories: Git
---

안녕하세요.  
프로젝트 관리와 팀 협업을 효율적으로 하기 위해 Git Flow를 활용하고 있습니다.  
이번에는 Git 브랜치 전략에 대해서 소개하려고 합니다.  

# Git Flow 전략

---

먼저 Git-flow에 대해서 간단히 살펴보겠습니다.  
Flow란 직역하여 흐름이라는 의미입니다. Git-flow는 git에서 제공하는 브랜칭 기능을 활용한 변경 이력 관리 전략이라고 이해하시면 됩니다.

Git-flow에는 5가지 종류의 브랜치가 존재합니다.  
항상 유지되는 메인 브랜치들(**master**, **develop**)과 일정 기간 동안만 유지되는 보조 브랜치들(**feature**, **release**, **hotfix**)이 있습니다.

- **`master`** : 기준이 되는 브랜치로 제품을 배포하는 브랜치 입니다.
- **`develop`** : feature에서 개발된 내용이 저장되는 브랜치입니다.
- **`feature`** : 단위 기능을 개발하는 브랜치로 기능 개발이 완료되면 develop 브랜치에 병합 합니다.
- **`release`** : 배포를 위해 master 브랜치로 보내기 전에 먼저 QA(품질검사)를 하기 위한 브랜치 입니다.
- **`hotfix`** : master 브랜치로 배포를 했는데 버그가 생겼을 때 긴급 수정하는 브랜치 입니다.

아래는 Git-flow를 이해할 때 가장 많이 사용되는 이미지 입니다.  
![images](/images/2024-01-29-second/git-flow_overall_graph.png)

### 일반적인 개발 흐름을 살펴보겠습니다.

1. **master** 브랜치에서 시작하여, 모든 출시 가능한 기능들이 이 브랜치에 있습니다.
2. 동일한 브랜치를 **develop**에도 생성합니다. 개발자들은 이 develop 브랜치에서 개발을 진행합니다.
3. 개발을 진행하다가 회원가입, 결제하기 등의 새로운 기능 구현이 필요할 경우 개발자는 develop 브랜치에서 **feature** 브랜치를 생성하여 기능을 구현합니다.
4. 완료된 feature 브랜치는 **develop** 브랜치에 병합 합니다.(Merge)
5. 모든 기능이 완료되면 develop 브랜치를 **release** 브랜치로 만듭니다. 그리고 OA(품질검사)를 진행하면서 발생한 버그들은 **release** 브랜치에 수정됩니다.
6. QA(품질검사)를 무사히 통과했다면 **release** 브랜치를 **master**과 **develop** 브랜치로 병합 합니다.(Merge)
7. **master** 브랜치에서 버전추가를 위해 태그를 하나 생성하고 배포를 합니다.
8. 배포를 했는데 미처 발견하지 못한 버그가 있을 경우 **hotfixes** 브랜치를 만들어 긴급 수정 후 태그를 생성하고 바로 수정 배포를 진행합니다. 

<br>

# Git Flow 예시

---

일반적인 개발 흐름을 살펴보았습니다. 간단한 웹 애플리케이션 MyWebApp 프로젝트를 만든다고 가정하고 Git Flow 전략에 따라 프로젝트가 어떻게 진행될 수 있는지 살펴보겠습니다.  

<br>

1. `master` 브랜치 초기화
   - 프로젝트 시작 시, `master` 브랜치는 출시 가능한 안정적인 코드만 포함합니다.

<br>

2. `develop` 브랜치로 새 기능 개발
   - 프로젝트의 모든 개발 작업은 `develop` 브랜치에서 시작됩니다.

   ```bash
   git checkout -b develop master
   ```
   
<br>

3. 새 기능 개발을 위한 `feature` 브랜치 생성
   - 예를 들어, 회원가입 기능(`feature-signup`) 개발을 위해 `feature-signup` 브랜치를 생성합니다.

   ```bash
   git checkout -b feature-signup develop
   ```
   
4. `develop` 브랜치의 최신 변경 사항을 `feature` 브랜치로 `rebase`
   - 커밋을 순차적으로 만들기 위해서 작업한 커밋이 `feature`의 최신 상태에서 시작하도록 rebase를 수행합니다.
   
   ```bash
   git fetch origin
   git rebase origin/develop
   ```
   
<br>

5. `feature` 브랜치를 `develop`에 병합
   - `feature-signup` 개발 완료 후, `develop` 브랜치로 이동하여 `feature-signup` 브랜치를 병합합니다.
   
   ```bash
   git checkout develop
   git merge feature-signup
   ```
   
<br>

6. 출시를 위한 `release` 브랜치 생성 및 QA
   - 모든 필요한 기능이 `develop`에 병합되어 새 출시 버전이 준비되면, `release-1.0` 브랜치를 생성합니다.
   
   ```bash
   git checkout -b release-1.0 develop
   ```
   
   - `release-1.0` 브랜치에서 QA 테스트를 진행하고 발견된 버그를 수정합니다.
   - 수정 사항은 이 브랜치에서 직접 처리되며, QA에 의해 재테스트 됩니다.

<br>

7. `release` 브랜치를 `master`와 `develop`에 병합 및 태깅
   - QA를 통과하면, `release-1.0` 브랜치를 `master`에 병합하고 `v1.0` 태그를 추가하여 출시합니다.
   
   ```bash
   git checkout master
   git merge release-1.0
   git tag -a v1.0 -m "Release version 1.0"
   ```
   
   - 또한, `release-1.0` 브랜치에서의 변경 사항을 `develop` 브랜치에도 반영합니다.
   
   ```bash
   git checkout develop
   git merge release-1.0
   ```
   
<br>

8. 긴급 수정을 위한 `hotfix` 브랜치 사용
   - 출시 후 긴급하게 수정해야 할 버그가 발견된 경우, **`hotfix-1.0.1` 브랜치를 `master`에서 생성**하고 수정을 진행합니다.
   
   ```bash
   git checkout -b hotfix-1.0.1 master
   ```
   
   - 수정 완료 후, `hotfix-1.0.1` 브랜치를 `master`와 `develop`에 병합하고 `v1.0.1` 태그를 추가하여 수정된 버전을 배포합니다.
   
   ```bash
   git checkout master
   git merge hotfix-1.0.1
   git tag -a v1.0.1 -m "Hotfix version 1.0.1"
   git checkout develop
   git merge hotfix-1.0.1
   ```
   
<br>

# Git Flow 실수를 줄이기 위해

---

저처럼 Git Flow를 자주 사용해보지 않거나 익숙하지 않았을 때 실수할 수 있습니다. 예를 들어, 제품 출시가 완료되었는데 버그가 발견돼서 긴급하게 고쳐야 할 경우가 있습니다.  
이런 경우 Git Flow 전략을 사용하면 `master` 브랜치에서 `hotfix` 브랜치를 생성해야 하는데 `develop` 브랜치에서 `hotfix` 브랜치를 생성하여 버그를 수정한 후 태깅을 한 실수를 한 적 있습니다.  
이런 실수를 막기 위해 commit을 하기 전에 Git Flow 전략이 잘 지켜졌는지 검증이 되면 어떨까 라는 생각을 하게 되었습니다.  

<br>

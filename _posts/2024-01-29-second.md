---
layout: single
title: "Git Flow란, Git 브랜치 전략"
categories: Git
---

안녕하세요.  
프로젝트 관리와 팀 협업을 효율적으로 하기 위해 Git Flow를 활용하고 있습니다.  
이번에는 Git 브랜치 전략에 대해서 소개하려고 합니다.  

# Git Flow 전략

---

먼저 Git-flow에 대해서 간단히 살펴보겠습니다.  
Flow란 직역하여 흐름이라는 의미입니다. Git-flow는 git에서 제공하는 브랜칭 기능을 활용한 변경 이력 관리 전략이라고 이해하시면 됩니다.

Git-flow에는 5가지 종류의 브랜치가 존재합니다.  
항상 유지되는 메인 브랜치들(**master**, **develop**)과 일정 기간 동안만 유지되는 보조 브랜치들(**feature**, **release**, **hotfix**)이 있습니다.

- **`master`** : 기준이 되는 브랜치로 제품을 배포하는 브랜치 입니다.
- **`develop`** : feature에서 개발된 내용이 저장되는 브랜치입니다.
- **`feature`** : 단위 기능을 개발하는 브랜치로 기능 개발이 완료되면 develop 브랜치에 병합 합니다.
- **`release`** : 배포를 위해 master 브랜치로 보내기 전에 먼저 QA(품질검사)를 하기 위한 브랜치 입니다.
- **`hotfix`** : master 브랜치로 배포를 했는데 버그가 생겼을 때 긴급 수정하는 브랜치 입니다.

아래는 Git-flow를 이해할 때 가장 많이 사용되는 이미지 입니다.  
![images](/images/2024-01-29-second/git-flow_overall_graph.png)

### 일반적인 개발 흐름을 살펴보겠습니다.

1. **master** 브랜치에서 시작하여, 모든 출시 가능한 기능들이 이 브랜치에 있습니다.
2. 동일한 브랜치를 **develop**에도 생성합니다. 개발자들은 이 develop 브랜치에서 개발을 진행합니다.
3. 개발을 진행하다가 회원가입, 결제하기 등의 새로운 기능 구현이 필요할 경우 개발자는 develop 브랜치에서 **feature** 브랜치를 생성하여 기능을 구현합니다.
4. 완료된 feature 브랜치는 **develop** 브랜치에 병합 합니다.(Merge)
5. 모든 기능이 완료되면 develop 브랜치를 **release** 브랜치로 만듭니다. 그리고 OA(품질검사)를 진행하면서 발생한 버그들은 **release** 브랜치에 수정됩니다.
6. QA(품질검사)를 무사히 통과했다면 **release** 브랜치를 **master**과 **develop** 브랜치로 병합 합니다.(Merge)
7. **master** 브랜치에서 버전추가를 위해 태그를 하나 생성하고 배포를 합니다.
8. 배포를 했는데 미처 발견하지 못한 버그가 있을 경우 **hotfixes** 브랜치를 만들어 긴급 수정 후 태그를 생성하고 바로 수정 배포를 진행합니다. 

<br>

# Git Flow 예시

---

일반적인 개발 흐름을 살펴보았습니다. 간단한 웹 애플리케이션 MyWebApp 프로젝트를 만든다고 가정하고 Git Flow 전략에 따라 프로젝트가 어떻게 진행될 수 있는지 살펴보겠습니다.  

1. `master` 브랜치 초기화
   - 프로젝트 시작 시, `master` 브랜치는 출시 가능한 안정적인 코드만 포함합니다.

2. `develop` 브랜치로 새 기능 개발
   - 프로젝트의 모든 개발 작업은 `develop` 브랜치에서 시작됩니다.

   ```Bash
   git checkout -b develop master
   ```

3. 새 기능 개발을 위한 `feature` 브랜치 생성
   - 예를 들어, 회원가입 기능(`feature-signup`) 개발을 위해 `feature-signup` 브랜치를 생성합니다.

   ```Bash
   git checkout -b feature-signup develop
   ```
   
4. `develop` 브랜치의 최신 변경 사항을 `feature` 브랜치로 `rebase`
   - 커밋을 순차적으로 만들기 위해서 작업한 커밋이 `feature`의 최신 상태에서 시작하도록 `rebase`를 수행합니다.
   
   ```Bash
   git fetch origin
   git rebase origin/develop
   ```

5. `feature` 브랜치를 `develop`에 병합
   - `feature-signup` 개발 완료 후, `develop` 브랜치로 이동하여 `feature-signup` 브랜치를 병합합니다.
   
   ```Bash
   git checkout develop
   git merge feature-signup
   ```

6. 출시를 위한 `release` 브랜치 생성 및 QA
   - 모든 필요한 기능이 `develop`에 병합되어 새 출시 버전이 준비되면, `release-1.0` 브랜치를 생성합니다.
   
   ```Bash
   git checkout -b release-1.0 develop
   ```
   
   - `release-1.0` 브랜치에서 QA 테스트를 진행하고 발견된 버그를 수정합니다.
   - 수정 사항은 이 브랜치에서 직접 처리되며, QA에 의해 재테스트 됩니다.

7. `release` 브랜치를 `master`와 `develop`에 병합 및 태깅
   - QA를 통과하면, `release-1.0` 브랜치를 `master`에 병합하고 `v1.0` 태그를 추가하여 출시합니다.
   
   ```Bash
   git checkout master
   git merge release-1.0
   git tag -a v1.0 -m "Release version 1.0"
   ```
   
   - 또한, `release-1.0` 브랜치에서의 변경 사항을 `develop` 브랜치에도 반영합니다.
   
   ```Bash
   git checkout develop
   git merge release-1.0
   ```

8. 버그 수정을 위한 `hotfix` 브랜치 사용
   - 출시 후 긴급하게 수정해야 할 버그가 발견된 경우, **`hotfix-1.0.1` 브랜치를 `master`에서 생성**하고 수정을 진행합니다.
   
   ```Bash
   git checkout -b hotfix-1.0.1 master
   ```
   
   - 수정 완료 후, `hotfix-1.0.1` 브랜치를 `master`와 `develop`에 병합하고 `v1.0.1` 태그를 추가하여 수정된 버전을 배포합니다.
   
   ```Bash
   git checkout master
   git merge hotfix-1.0.1
   git tag -a v1.0.1 -m "Hotfix version 1.0.1"
   git checkout develop
   git merge hotfix-1.0.1
   ```
   
<br>

# Git Flow 실수를 줄이기 위해

---

저처럼 Git Flow를 자주 사용해보지 않거나 익숙하지 않았을 때 실수할 수 있습니다. 예를 들어, 제품 출시한 후 버그가 발견돼서 긴급하게 고쳐야 할 경우가 있습니다.  
이런 경우 Git Flow 전략을 사용하면 `master` 브랜치에서 `hotfix` 브랜치를 생성해야 하는데 `develop` 브랜치에서 `hotfix` 브랜치를 생성하여 버그를 수정한 실수를 한 적 있습니다. 
이런 실수를 막기 위해 `commit`을 하기 전에 Git Flow 전략이 잘 지켜졌는지 검증이 되면 어떨까 라는 생각을 하게 되었습니다.  
저는 Husky를 사용하여 pre-commit 훅에 스크립트를 연결함으로써, hotfix 브랜치가 master로 부터 올바르게 분기되었는지 자동으로 검증하는 방법을 선택하였습니다.

## Husky를 사용하여 pre-commit 훅에 스크립트 연결
저희 회사에서는 브랜치를 생성할 때 네이밍 규칙을 사용합니다. 예를 들어, `develop`에서 `feature` 브랜치를 생성하면 **feature/오늘날짜(YYYYMMDD)-develop-작업명**, hotfix 브랜치 생성 시 **hotfix/오늘날짜(YYYYMMDD)-master-작업명**으로 생성하고 있습니다.  
만약 회원가입 기능 브랜치를 생성한다면 `feature/20240129-develop-signup` 이런식으로 네이밍 규칙을 따르고 있습니다.  
이런 네이밍 규칙을 이용하여 아래와 같이 Git Flow 전략 검증을 하였습니다.

### 1. Husky 설치
```Bash
npm install husky --save-dev
```

### 2. Husky 훅 설정
프로젝트 루트에 `.husky` 폴더를 생성합니다.
`.husky` 폴더 안에 `pre-commit` 파일을 생성합니다.
`pre-commit` 파일에 스크립트를 실행하는 명령어를 추가합니다. 예를 들어, `scripts/validateBranch.js`라는 스크립트를 실행하려면 다음과 같이 작성합니다.

```Bash
#!/bin/sh
. "$(dirname "$0")/_/husky.sh"

node scripts/validateBranch.js
```

### 3. 스크립트 작성
프로젝트 루트에 **scripts** 폴더를 생성하고, **validateBranch.js** 파일을 만듭니다.
해당 파일에 브랜치 이름을 검증하는 Node.js 스크립트를 작성합니다.

```Javascript
const { execSync } = require('child_process');

function getCurrentBranch() {
    return execSync('git rev-parse --abbrev-ref HEAD').toString().trim();
}

const currentBranch = getCurrentBranch();
const invalidPatterns = [/dev/, /develop/];

if (currentBranch.startsWith('hotfix/') && invalidPatterns.some(pattern => pattern.test(currentBranch))) {
    console.error('Error: Hotfix branch must be branched off from "master".');
    process.exit(1);
}
```

### 4. 테스트
설정이 완료되면, `hotfix` 브랜치를 잘못된 이름으로 생성하고 커밋을 시도하여 `pre-commit` 훅이 올바르게 작동하는지 확인합니다.
예를 들어, `git checkout -b hotfix/20240120-develop-test`와 같이 실행한 후 커밋을 시도하면 validateBranch.js 스크립트가 실행되어 잘못된 브랜치 이름으로 인해 에러 메시지가 표시되고 커밋이 거부 됩니다.  
![images](/images/2024-01-29-second/hotfix%20test.png)  
이렇게 네이밍 규칙을 사용한다면 `hotfix` 브랜치 경우 `develop`에서 생성되는 실수를 방지할 수 있습니다.